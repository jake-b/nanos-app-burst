#!/usr/bin/env python3.6

import os
import axolotl_curve25519 as curve_waveslib
import burst_curve25519 as curve_burstlib
import hashlib
import binascii

passphrase = "password".encode('utf-8')
secret = hashlib.sha256(passphrase).digest()
message = "message"

# generate keys using the library used for Burstcoin:
# public_key, _, private_key = curve_burstlib.curve25519_eckcdsa_keygen(secret)

private_key = bytes.fromhex("6849466fd6e077184414975aa634d791d34ff1e33aaac35fd00a06759ab76757")
public_key = bytes.fromhex("54638c72989a2a69be661dfb74fe08511bdcf0d296852caf695c0a0cea5e5742")

print ("Private key:\t\t", binascii.hexlify(private_key))
print ("Public Key:\t\t", binascii.hexlify(public_key))


# use the waves-compatible lib to sign and verify using the keys generated by burst:
def sign(privateKey, message):
    random64 = os.urandom(64)
    return curve_waveslib.calculateSignature(random64, privateKey, message)


def sign2(privateKey, message):
    return curve_burstlib.kcdsa_sign(message, privateKey)


def validate(pk, m, s):
    return curve_waveslib.verifySignature(pk, m, s) == 0


def validate2(pk, m, s):
    return curve_burstlib.kcdsa_verify(s, m, pk)


m = bytes.fromhex("31")

s = sign(private_key, m)
s2 = sign2(private_key, m)

print ("Signature waveslib  :", binascii.hexlify(s))
print ("Signature burstlib  :", binascii.hexlify(s2))

print ("Validates waveslib signature using waveslib? :", validate(public_key, m, s))
print ("Validates burstlib signature using waveslib? :", validate(public_key, m, s2))

print ("Validates waveslib signature using burstlib? :", validate2(public_key, m, s))
print ("Validates burstlib signature using burstlib? :", validate2(public_key, m, s2))
